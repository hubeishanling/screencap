// æ¸²æŸ“è¿›ç¨‹è„šæœ¬ - ADBæˆªå›¾å·¥å…·ï¼ˆæ¨¡å—åŒ–ç‰ˆæœ¬ï¼‰

// å…¨å±€çŠ¶æ€ï¼ˆç®€åŒ–ï¼‰
window.currentImagePath = null;
window.currentImageData = null;

// DOMå…ƒç´ é›†åˆ
let elements = {};

// é¡µé¢åŠ è½½å®Œæˆåæ‰§è¡Œ
document.addEventListener('DOMContentLoaded', async () => {
    initializeApp();
    setupEventListeners();
    await window.HistoryManager.loadHistoryFromDisk();
    window.DeviceManager.refreshDevices();
});

// åˆå§‹åŒ–åº”ç”¨
function initializeApp() {
    // ç¼“å­˜æ‰€æœ‰DOMå…ƒç´ 
    elements = {
        // è®¾å¤‡ç›¸å…³
        deviceSelect: document.getElementById('device-select'),
        refreshDevicesBtn: document.getElementById('refresh-devices-btn'),
        captureBtn: document.getElementById('capture-btn'),
        dumpUIBtn: document.getElementById('dump-ui-btn'),
        
        // å†å²è®°å½•
        clearHistoryBtn: document.getElementById('clear-history-btn'),
        historyList: document.getElementById('history-list'),
        
        // çŠ¶æ€æ¶ˆæ¯
        statusMessage: document.getElementById('status-message'),
        
        // ç”»å¸ƒç›¸å…³
        imageCanvas: document.getElementById('image-canvas'),
        imageContainer: document.getElementById('image-container'),
        selectionOverlay: document.getElementById('selection-overlay'),
        selectionBox: document.getElementById('selection-box'),
        bottomControls: document.querySelector('.bottom-controls'),
        
        // ç¼©æ”¾æ§åˆ¶
        zoomInBtn: document.getElementById('zoom-in-btn'),
        zoomOutBtn: document.getElementById('zoom-out-btn'),
        zoomResetBtn: document.getElementById('zoom-reset-btn'),
        zoomFitBtn: document.getElementById('zoom-fit-btn'),
        zoomLevel: document.getElementById('zoom-level'),
        
        // è£å‰ªé¢„è§ˆ
        cropCanvas: document.getElementById('crop-canvas'),
        cropPreviewContainer: document.getElementById('crop-preview-container'),
        cropWidth: document.getElementById('crop-width'),
        cropHeight: document.getElementById('crop-height'),
        cropX: document.getElementById('crop-x'),
        cropY: document.getElementById('crop-y'),
        saveCropBtn: document.getElementById('save-crop-btn'),
        saveOriginalBtn: document.getElementById('save-original-btn'),
        resetSelectionBtn: document.getElementById('reset-selection-btn'),
        
        // æ ‡ç­¾é¡µ
        cropTabBtn: document.getElementById('crop-tab-btn'),
        nodesTabBtn: document.getElementById('nodes-tab-btn'),
        cropPanel: document.getElementById('crop-panel'),
        nodesPanel: document.getElementById('nodes-panel'),
        
        // èŠ‚ç‚¹æ ‘
        nodesTree: document.getElementById('nodes-tree'),
        nodeDetails: document.getElementById('node-details'),
        nodeSearch: document.getElementById('node-search'),
        expandAllBtn: document.getElementById('expand-all-btn'),
        collapseAllBtn: document.getElementById('collapse-all-btn'),
        nodeHighlightOverlay: document.getElementById('node-highlight-overlay'),
        nodeHighlightBox: document.getElementById('node-highlight-box'),
        
        // ä¾§è¾¹æ è°ƒæ•´
        sidebarResizer: document.getElementById('sidebar-resizer'),
        sidebarRight: document.getElementById('sidebar-right')
    };
    
    // åˆå§‹åŒ–å„ä¸ªæ¨¡å—
    window.Utils.initStatusElement(elements.statusMessage);
    window.DeviceManager.initElements(elements);
    window.HistoryManager.initElements(elements);
    window.ScreenshotManager.initElements(elements);
    window.CanvasManager.initElements(elements);
    window.NodeManager.initElements(elements);
    window.UIManager.initElements(elements);
}

// è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
function setupEventListeners() {
    // è®¾å¤‡ç®¡ç†
    elements.refreshDevicesBtn.addEventListener('click', () => window.DeviceManager.refreshDevices());
    elements.deviceSelect.addEventListener('change', () => window.DeviceManager.onDeviceChange());
    
    // æˆªå›¾ç›¸å…³
    elements.captureBtn.addEventListener('click', () => window.ScreenshotManager.captureScreen());
    elements.saveCropBtn.addEventListener('click', () => window.ScreenshotManager.saveCroppedImage());
    elements.saveOriginalBtn.addEventListener('click', () => window.ScreenshotManager.saveOriginalImage());
    
    // èŠ‚ç‚¹æŠ“å–
    elements.dumpUIBtn.addEventListener('click', () => window.NodeManager.dumpUIHierarchy());
    
    // å†å²è®°å½•
    elements.clearHistoryBtn.addEventListener('click', () => window.HistoryManager.clearHistory());
    
    // ç”»å¸ƒç®¡ç†å™¨äº‹ä»¶ï¼ˆåœ¨CanvasManagerå†…éƒ¨è®¾ç½®ï¼‰
    window.CanvasManager.setupEventListeners();
    
    // èŠ‚ç‚¹ç®¡ç†å™¨äº‹ä»¶ï¼ˆåœ¨NodeManagerå†…éƒ¨è®¾ç½®ï¼‰
    window.NodeManager.setupEventListeners();
    
    // UIç®¡ç†å™¨äº‹ä»¶ï¼ˆåœ¨UIManagerå†…éƒ¨è®¾ç½®ï¼‰
    window.UIManager.setupEventListeners();
}
    
    try {
        const result = await window.electronAPI.checkAdbDevices();
        
        if (result.success && result.devices.length > 0) {
            // å¡«å……è®¾å¤‡ä¸‹æ‹‰åˆ—è¡¨
            elements.deviceSelect.innerHTML = '<option value="">é€‰æ‹©è®¾å¤‡</option>';
            result.devices.forEach(device => {
                const option = document.createElement('option');
                option.value = device.id;
                option.textContent = `${device.id} (${device.status})`;
                elements.deviceSelect.appendChild(option);
            });
            elements.deviceSelect.disabled = false;
            if (!silent) {
                showStatus(`æ‰¾åˆ° ${result.devices.length} ä¸ªè®¾å¤‡`, 'success');
            }
        } else {
            elements.deviceSelect.innerHTML = '<option value="">æœªæ£€æµ‹åˆ°è®¾å¤‡</option>';
            if (!silent) {
                showStatus('æœªæ£€æµ‹åˆ°è®¾å¤‡ï¼Œè¯·è¿æ¥Androidè®¾å¤‡å¹¶å¼€å¯USBè°ƒè¯•', 'warning');
            }
        }
    } catch (error) {
        elements.deviceSelect.innerHTML = '<option value="">æ£€æŸ¥å¤±è´¥</option>';
        if (!silent) {
            showStatus(`é”™è¯¯: ${error.message}`, 'error');
        }
    }
}

// è®¾å¤‡é€‰æ‹©å˜åŒ–
function onDeviceChange() {
    selectedDevice = elements.deviceSelect.value;
    elements.captureBtn.disabled = !selectedDevice;
    elements.dumpUIBtn.disabled = !selectedDevice;
}

// ========== æˆªå›¾åŠŸèƒ½ ==========

// æˆªå–å±å¹•
async function captureScreen() {
    if (!selectedDevice) {
        showStatus('è¯·å…ˆé€‰æ‹©è®¾å¤‡', 'warning');
        return;
    }
    
    showStatus('æ­£åœ¨æˆªå›¾...', 'info');
    elements.captureBtn.disabled = true;
    
    try {
        const result = await window.electronAPI.captureScreen(selectedDevice);
        
        if (result.success) {
            currentImagePath = result.imagePath;
            await loadAndDisplayImage(currentImagePath);
            
            // æ·»åŠ åˆ°å†å²è®°å½•ï¼ˆä½¿ç”¨æœåŠ¡å™¨è¿”å›çš„æ–‡ä»¶åå’Œæ—¶é—´æˆ³ï¼‰
            addToHistory(result.imagePath, result.fileName, result.timestamp);
            
            // å¯ç”¨ä¿å­˜åŸå›¾æŒ‰é’®
            elements.saveOriginalBtn.disabled = false;
            
            showStatus('æˆªå›¾æˆåŠŸï¼ä½¿ç”¨é¼ æ ‡åœ¨å›¾ç‰‡ä¸Šæ¡†é€‰éœ€è¦è£å‰ªçš„åŒºåŸŸ', 'success');
        } else {
            showStatus(`æˆªå›¾å¤±è´¥: ${result.error}`, 'error');
        }
    } catch (error) {
        showStatus(` æˆªå›¾å¤±è´¥: ${error.message}`, 'error');
    } finally {
        elements.captureBtn.disabled = false;
    }
}

// åŠ è½½å¹¶æ˜¾ç¤ºå›¾ç‰‡
function loadAndDisplayImage(imagePath) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
            currentImageData = img;
            
            // è®¡ç®—åˆå§‹ç¼©æ”¾æ¯”ä¾‹ä»¥é€‚åº”å®¹å™¨
            const containerRect = elements.imageContainer.getBoundingClientRect();
            const maxWidth = containerRect.width - 40;
            const maxHeight = containerRect.height - 40;
            
            scale = Math.min(
                maxWidth / img.width,
                maxHeight / img.height,
                1
            );
            
            // é‡ç½®ç¼©æ”¾çº§åˆ«
            zoomLevel = 1;
            
            // ç»˜åˆ¶å›¾ç‰‡
            redrawCanvas();
            
            // æ˜¾ç¤ºcanvaså’Œç¼©æ”¾æ§åˆ¶
            const placeholder = elements.imageContainer.querySelector('.placeholder-text');
            if (placeholder) placeholder.style.display = 'none';
            elements.imageCanvas.style.display = 'block';
            elements.bottomControls.classList.add('active');
            elements.imageContainer.classList.add('has-image');
            
            // æ›´æ–°ç¼©æ”¾æ˜¾ç¤º
            updateZoomDisplay();
            
            // é‡ç½®é€‰åŒº
            resetSelection();
            
            // éšè—èŠ‚ç‚¹é«˜äº®
            hideNodeHighlight();
            
            resolve();
        };
        img.onerror = reject;
        img.src = imagePath;
    });
}

// é‡ç»˜canvas
function redrawCanvas() {
    if (!currentImageData) return;
    
    // è®¡ç®—å½“å‰æ˜¾ç¤ºå°ºå¯¸
    const displayWidth = currentImageData.width * scale * zoomLevel;
    const displayHeight = currentImageData.height * scale * zoomLevel;
    
    // è®¾ç½®canvaså°ºå¯¸
    elements.imageCanvas.width = displayWidth;
    elements.imageCanvas.height = displayHeight;
    
    // ç»˜åˆ¶å›¾ç‰‡
    const ctx = elements.imageCanvas.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(currentImageData, 0, 0, displayWidth, displayHeight);
    
    // è®¡ç®—canvasåœ¨å®¹å™¨ä¸­çš„åç§»
    updateCanvasOffset();
    
    // å¦‚æœæœ‰é€‰ä¸­çš„èŠ‚ç‚¹ï¼Œæ›´æ–°é«˜äº®ä½ç½®
    if (selectedNode) {
        highlightNodeOnImage(selectedNode);
    }
}

// æ›´æ–°canvasåç§»é‡
function updateCanvasOffset() {
    const canvasRect = elements.imageCanvas.getBoundingClientRect();
    const containerRect = elements.imageContainer.getBoundingClientRect();
    canvasOffset.x = canvasRect.left - containerRect.left;
    canvasOffset.y = canvasRect.top - containerRect.top;
}

// ========== é¼ æ ‡æ¡†é€‰åŠŸèƒ½ ==========

// Canvasé¼ æ ‡æŒ‰ä¸‹
function onCanvasMouseDown(e) {
    if (!currentImageData) return;
    
    // åªæœ‰å·¦é”®æ‰å¼€å§‹æ¡†é€‰
    if (e.button !== 0) return;
    
    isSelecting = true;
    const rect = elements.imageCanvas.getBoundingClientRect();
    selectionStart.x = e.clientX - rect.left;
    selectionStart.y = e.clientY - rect.top;
    selectionEnd = { ...selectionStart };
    
    elements.selectionBox.style.display = 'none';
    elements.selectionOverlay.style.display = 'block';
    
    e.preventDefault();
}

// Canvasé¼ æ ‡è¿›å…¥
function onCanvasMouseEnter(e) {
    if (currentImageData && crosshair) {
        crosshair.style.display = 'block';
    }
}

// Canvasé¼ æ ‡ç§»åŠ¨
function onCanvasMouseMove(e) {
    if (!currentImageData) return;
    
    const rect = elements.imageCanvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // æ›´æ–°åå­—å…‰æ ‡ä½ç½®
    updateCrosshair(mouseX, mouseY, rect);
    
    // å¦‚æœæ­£åœ¨æ¡†é€‰ï¼Œæ›´æ–°é€‰åŒº
    if (isSelecting) {
        selectionEnd.x = mouseX;
        selectionEnd.y = mouseY;
        
        // é™åˆ¶åœ¨canvasèŒƒå›´å†…
        selectionEnd.x = Math.max(0, Math.min(selectionEnd.x, elements.imageCanvas.width));
        selectionEnd.y = Math.max(0, Math.min(selectionEnd.y, elements.imageCanvas.height));
        
        updateSelectionBox();
    }
}

// Canvasé¼ æ ‡æŠ¬èµ·
function onCanvasMouseUp(e) {
    if (!isSelecting) return;
    
    isSelecting = false;
    
    const width = Math.abs(selectionEnd.x - selectionStart.x);
    const height = Math.abs(selectionEnd.y - selectionStart.y);
    
    // å¦‚æœé€‰åŒºå¤ªå°ï¼ˆç‚¹å‡»è€Œéæ¡†é€‰ï¼‰
    if (width < 10 || height < 10) {
        resetSelection();
        
        // å¦‚æœæœ‰èŠ‚ç‚¹æ•°æ®ï¼Œå°è¯•æŸ¥æ‰¾ç‚¹å‡»ä½ç½®å¯¹åº”çš„èŠ‚ç‚¹
        if (uiHierarchyData) {
            const rect = elements.imageCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            // è½¬æ¢ä¸ºåŸå§‹å›¾ç‰‡åæ ‡
            const originalX = Math.round(clickX / (scale * zoomLevel));
            const originalY = Math.round(clickY / (scale * zoomLevel));
            
            console.log('ç‚¹å‡»åæ ‡:', { clickX, clickY, originalX, originalY, scale, zoomLevel });
            
            // æŸ¥æ‰¾å¯¹åº”çš„èŠ‚ç‚¹
            const foundNode = findNodeByCoordinates(originalX, originalY);
            
            if (foundNode) {
                console.log('æ‰¾åˆ°èŠ‚ç‚¹:', foundNode);
                // åœ¨æ ‘ä¸­å±•å¼€å¹¶é€‰ä¸­èŠ‚ç‚¹
                expandAndSelectNodeInTree(foundNode);
            } else {
                console.log('æœªæ‰¾åˆ°èŠ‚ç‚¹ï¼Œå°è¯•æŸ¥æ‰¾æ ¹èŠ‚ç‚¹:', uiHierarchyData);
                showStatus(`è¯¥ä½ç½®æœªæ‰¾åˆ°å¯¹åº”çš„UIèŠ‚ç‚¹ (åæ ‡: ${originalX}, ${originalY})`, 'warning');
            }
        }
        
        return;
    }
    
    // æ˜¾ç¤ºé€‰åŒºå¹¶æ›´æ–°è£å‰ªé¢„è§ˆ
    updateSelectionBox();
    updateCropPreview();
}

// Canvasé¼ æ ‡ç¦»å¼€
function onCanvasMouseLeave(e) {
    // éšè—åå­—å…‰æ ‡
    if (crosshair) {
        crosshair.style.display = 'none';
    }
    
    // å¦‚æœæ­£åœ¨æ¡†é€‰ï¼Œåœæ­¢æ¡†é€‰
    if (isSelecting) {
        onCanvasMouseUp(e);
    }
}

// æ›´æ–°åå­—å…‰æ ‡ä½ç½®
function updateCrosshair(mouseX, mouseY, canvasRect) {
    if (!crosshair || !currentImageData) return;
    
    // è½¬æ¢ä¸ºåŸå§‹å›¾ç‰‡åæ ‡
    const originalX = Math.round(mouseX / (scale * zoomLevel));
    const originalY = Math.round(mouseY / (scale * zoomLevel));
    
    // æ›´æ–°åå­—çº¿ä½ç½®ï¼ˆç°åœ¨ç›¸å¯¹äºcanvas-wrapperï¼Œä¸éœ€è¦offsetï¼‰
    crosshairH.style.top = mouseY + 'px';
    crosshairV.style.left = mouseX + 'px';
    
    // æ›´æ–°åæ ‡æ˜¾ç¤º
    crosshairCoords.textContent = `${originalX}, ${originalY}`;
    
    // è®¡ç®—åæ ‡æ¡†çš„ä½ç½®ï¼Œé¿å…è¶…å‡ºè¾¹ç•Œ
    let coordX = mouseX + 15;
    let coordY = mouseY + 15;
    
    // å¦‚æœåæ ‡æ¡†ä¼šè¶…å‡ºå³è¾¹ç•Œï¼Œæ”¾åˆ°é¼ æ ‡å·¦è¾¹
    if (coordX + 100 > elements.imageCanvas.width) {
        coordX = mouseX - 100;
    }
    
    // å¦‚æœåæ ‡æ¡†ä¼šè¶…å‡ºä¸‹è¾¹ç•Œï¼Œæ”¾åˆ°é¼ æ ‡ä¸Šè¾¹
    if (coordY + 30 > elements.imageCanvas.height) {
        coordY = mouseY - 35;
    }
    
    crosshairCoords.style.left = coordX + 'px';
    crosshairCoords.style.top = coordY + 'px';
}

// æ›´æ–°é€‰åŒºæ¡†
function updateSelectionBox() {
    const left = Math.min(selectionStart.x, selectionEnd.x);
    const top = Math.min(selectionStart.y, selectionEnd.y);
    const width = Math.abs(selectionEnd.x - selectionStart.x);
    const height = Math.abs(selectionEnd.y - selectionStart.y);
    
    // ç°åœ¨ç›¸å¯¹äºcanvas-wrapperï¼Œä¸éœ€è¦canvasOffset
    elements.selectionBox.style.left = left + 'px';
    elements.selectionBox.style.top = top + 'px';
    elements.selectionBox.style.width = width + 'px';
    elements.selectionBox.style.height = height + 'px';
    elements.selectionBox.style.display = 'block';
}

// æ›´æ–°è£å‰ªé¢„è§ˆ
function updateCropPreview() {
    const left = Math.min(selectionStart.x, selectionEnd.x);
    const top = Math.min(selectionStart.y, selectionEnd.y);
    const width = Math.abs(selectionEnd.x - selectionStart.x);
    const height = Math.abs(selectionEnd.y - selectionStart.y);
    
    // è½¬æ¢ä¸ºåŸå§‹å›¾ç‰‡åæ ‡
    const originalX = Math.round(left / (scale * zoomLevel));
    const originalY = Math.round(top / (scale * zoomLevel));
    const originalWidth = Math.round(width / (scale * zoomLevel));
    const originalHeight = Math.round(height / (scale * zoomLevel));
    
    // æ›´æ–°å°ºå¯¸ä¿¡æ¯
    elements.cropWidth.textContent = originalWidth;
    elements.cropHeight.textContent = originalHeight;
    elements.cropX.textContent = originalX;
    elements.cropY.textContent = originalY;
    
    // åœ¨å³ä¾§é¢„è§ˆcanvasä¸­ç»˜åˆ¶è£å‰ªåŒºåŸŸ
    const previewMaxSize = 280;
    const previewScale = Math.min(
        previewMaxSize / originalWidth,
        previewMaxSize / originalHeight,
        1
    );
    
    elements.cropCanvas.width = originalWidth * previewScale;
    elements.cropCanvas.height = originalHeight * previewScale;
    
    const cropCtx = elements.cropCanvas.getContext('2d');
    cropCtx.drawImage(
        currentImageData,
        originalX, originalY, originalWidth, originalHeight,
        0, 0, elements.cropCanvas.width, elements.cropCanvas.height
    );
    
    // æ˜¾ç¤ºé¢„è§ˆå’ŒæŒ‰é’®
    elements.cropCanvas.classList.add('active');
    const emptyState = elements.cropPreviewContainer.querySelector('.empty-state');
    if (emptyState) emptyState.style.display = 'none';
    
    elements.saveCropBtn.disabled = false;
    elements.resetSelectionBtn.disabled = false;
}

// é‡ç½®é€‰åŒº
function resetSelection() {
    isSelecting = false;
    selectionStart = { x: 0, y: 0 };
    selectionEnd = { x: 0, y: 0 };
    
    elements.selectionBox.style.display = 'none';
    elements.selectionOverlay.style.display = 'none';
    elements.cropCanvas.classList.remove('active');
    
    const emptyState = elements.cropPreviewContainer.querySelector('.empty-state');
    if (emptyState) emptyState.style.display = 'block';
    
    elements.cropWidth.textContent = '-';
    elements.cropHeight.textContent = '-';
    elements.cropX.textContent = '-';
    elements.cropY.textContent = '-';
    
    elements.saveCropBtn.disabled = true;
    elements.resetSelectionBtn.disabled = true;
}

// ========== ä¿å­˜åŠŸèƒ½ ==========

// ä¿å­˜è£å‰ªåçš„å›¾ç‰‡
async function saveCroppedImage() {
    const left = Math.min(selectionStart.x, selectionEnd.x);
    const top = Math.min(selectionStart.y, selectionEnd.y);
    const width = Math.abs(selectionEnd.x - selectionStart.x);
    const height = Math.abs(selectionEnd.y - selectionStart.y);
    
    const cropData = {
        x: left / (scale * zoomLevel),
        y: top / (scale * zoomLevel),
        width: width / (scale * zoomLevel),
        height: height / (scale * zoomLevel)
    };
    
    showStatus('æ­£åœ¨ä¿å­˜è£å‰ªå›¾ç‰‡...', 'info');
    elements.saveCropBtn.disabled = true;
    
    try {
        const cropResult = await window.electronAPI.cropImage(currentImagePath, cropData);
        
        if (cropResult.success) {
            const saveResult = await window.electronAPI.saveImage(cropResult.croppedPath);
            
            if (saveResult.success) {
                showStatus(`è£å‰ªå›¾ç‰‡å·²ä¿å­˜: ${saveResult.savedPath}`, 'success');
            } else {
                showStatus(`${saveResult.error}`, 'warning');
            }
        } else {
            showStatus(`è£å‰ªå¤±è´¥: ${cropResult.error}`, 'error');
        }
    } catch (error) {
        showStatus(`ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
    } finally {
        elements.saveCropBtn.disabled = false;
    }
}

// ä¿å­˜åŸå§‹å›¾ç‰‡
async function saveOriginalImage() {
    if (!currentImagePath) return;
    
    showStatus('æ­£åœ¨ä¿å­˜åŸå›¾...', 'info');
    elements.saveOriginalBtn.disabled = true;
    
    try {
        const result = await window.electronAPI.saveImage(currentImagePath);
        
        if (result.success) {
            showStatus(` åŸå›¾å·²ä¿å­˜: ${result.savedPath}`, 'success');
        } else {
            showStatus(`${result.error}`, 'warning');
        }
    } catch (error) {
        showStatus(`ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
    } finally {
        elements.saveOriginalBtn.disabled = false;
    }
}

// ========== å†å²è®°å½• ==========

// ä»ç£ç›˜åŠ è½½å†å²è®°å½•
async function loadHistoryFromDisk() {
    try {
        const result = await window.electronAPI.loadHistory();
        if (result.success && result.history) {
            historyData = result.history;
            updateHistoryList();
            
            // æ˜¾ç¤ºæˆªå›¾ä¿å­˜ç›®å½•
            const dirResult = await window.electronAPI.getScreenshotsDir();
            if (dirResult.success) {
                console.log('æˆªå›¾ä¿å­˜ç›®å½•:', dirResult.path);
            }
        }
    } catch (error) {
        console.error('åŠ è½½å†å²è®°å½•å¤±è´¥:', error);
    }
}

// ä¿å­˜å†å²è®°å½•åˆ°ç£ç›˜
async function saveHistoryToDisk() {
    try {
        await window.electronAPI.saveHistory(historyData);
    } catch (error) {
        console.error('ä¿å­˜å†å²è®°å½•å¤±è´¥:', error);
    }
}

// æ·»åŠ åˆ°å†å²è®°å½•
function addToHistory(imagePath, fileName, timestamp, xmlPath = null, xmlFileName = null) {
    const historyItem = {
        path: imagePath,
        timestamp: timestamp,
        fileName: fileName,
        id: Date.now(),
        xmlPath: xmlPath,  // èŠ‚ç‚¹æ•°æ®è·¯å¾„
        xmlFileName: xmlFileName,  // èŠ‚ç‚¹æ•°æ®æ–‡ä»¶å
        hasNodes: !!xmlPath  // æ ‡è®°æ˜¯å¦æœ‰èŠ‚ç‚¹æ•°æ®
    };
    
    historyData.unshift(historyItem);
    
    // é™åˆ¶å†å²è®°å½•æ•°é‡
    if (historyData.length > 50) {
        historyData = historyData.slice(0, 50);
    }
    
    updateHistoryList();
    saveHistoryToDisk(); // ä¿å­˜åˆ°ç£ç›˜
}

// æ›´æ–°å†å²è®°å½•åˆ—è¡¨
function updateHistoryList() {
    if (historyData.length === 0) {
        elements.historyList.innerHTML = '<p class="empty-state">æš‚æ— æˆªå›¾è®°å½•</p>';
        return;
    }
    
    elements.historyList.innerHTML = '';
    
    historyData.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'history-item';
        if (index === 0) div.classList.add('active');
        
        // æ·»åŠ èŠ‚ç‚¹æ•°æ®æ ‡è¯†
        const nodesBadge = item.hasNodes ? '' : '';
        
        div.innerHTML = `
            <div class="history-item-content">
                <div class="history-item-name">${nodesBadge} ${item.fileName}</div>
                <div class="history-item-time">${item.timestamp}</div>
            </div>
        `;
        
        div.addEventListener('click', () => {
            loadHistoryItem(item);
            // æ›´æ–°æ¿€æ´»çŠ¶æ€
            elements.historyList.querySelectorAll('.history-item').forEach(el => {
                el.classList.remove('active');
            });
            div.classList.add('active');
        });
        
        elements.historyList.appendChild(div);
    });
}

// åŠ è½½å†å²è®°å½•é¡¹
async function loadHistoryItem(item) {
    currentImagePath = item.path;
    await loadAndDisplayImage(item.path);
    elements.saveOriginalBtn.disabled = false;
    
    // å¦‚æœæœ‰èŠ‚ç‚¹æ•°æ®ï¼ŒåŠ è½½å¹¶æ˜¾ç¤ºèŠ‚ç‚¹æ ‘
    if (item.hasNodes && item.xmlPath) {
        try {
            const result = await window.electronAPI.loadUIXml(item.xmlPath);
            
            if (result.success) {
                // è§£æXMLæ•°æ®
                uiHierarchyData = parseUIXML(result.xmlContent);
                
                // æ¸²æŸ“èŠ‚ç‚¹æ ‘
                renderNodesTree(uiHierarchyData);
                
                showStatus('å·²åŠ è½½å†å²æˆªå›¾å’ŒèŠ‚ç‚¹ä¿¡æ¯ - å¯ç‚¹å‡»å›¾ç‰‡æŸ¥æ‰¾å¯¹åº”èŠ‚ç‚¹', 'success');
            } else {
                showStatus('å·²åŠ è½½å†å²æˆªå›¾ï¼ˆèŠ‚ç‚¹æ•°æ®åŠ è½½å¤±è´¥ï¼‰', 'warning');
                // æ¸…ç©ºèŠ‚ç‚¹æ ‘
                elements.nodesTree.innerHTML = '<p class="empty-state">èŠ‚ç‚¹æ•°æ®æ–‡ä»¶ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤</p>';
                uiHierarchyData = null;
            }
        } catch (error) {
            console.error('åŠ è½½èŠ‚ç‚¹æ•°æ®å¤±è´¥:', error);
            showStatus('å·²åŠ è½½å†å²æˆªå›¾ï¼ˆèŠ‚ç‚¹æ•°æ®åŠ è½½å¤±è´¥ï¼‰', 'warning');
            elements.nodesTree.innerHTML = '<p class="empty-state">èŠ‚ç‚¹æ•°æ®åŠ è½½å¤±è´¥</p>';
            uiHierarchyData = null;
        }
    } else {
        // æ²¡æœ‰èŠ‚ç‚¹æ•°æ®ï¼Œæ¸…ç©ºèŠ‚ç‚¹æ ‘
        elements.nodesTree.innerHTML = '<p class="empty-state">è¯¥æˆªå›¾æ²¡æœ‰èŠ‚ç‚¹ä¿¡æ¯</p>';
        uiHierarchyData = null;
        showStatus('å·²åŠ è½½å†å²æˆªå›¾', 'success');
    }
}

// æ¸…ç©ºå†å²è®°å½•
function clearHistory() {
    if (historyData.length === 0) return;
    
    if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•å—ï¼Ÿ\næ³¨æ„ï¼šè¿™ä¸ä¼šåˆ é™¤å·²ä¿å­˜çš„æˆªå›¾æ–‡ä»¶ã€‚')) {
        historyData = [];
        updateHistoryList();
        saveHistoryToDisk(); // ä¿å­˜åˆ°ç£ç›˜
        showStatus('å†å²è®°å½•å·²æ¸…ç©º', 'success');
    }
}

// ========== ç¼©æ”¾å’Œæ‹–åŠ¨åŠŸèƒ½ ==========

// ç¼©æ”¾å›¾ç‰‡
function zoomImage(delta) {
    if (!currentImageData) return;
    
    const newZoom = Math.max(minZoom, Math.min(maxZoom, zoomLevel + delta));
    if (newZoom === zoomLevel) return;
    
    zoomLevel = newZoom;
    redrawCanvas();
    updateZoomDisplay();
    resetSelection();
}

// é¼ æ ‡æ»šè½®ç¼©æ”¾
function onMouseWheel(e) {
    if (!currentImageData) return;
    
    e.preventDefault();
    const delta = e.deltaY > 0 ? -0.1 : 0.1;
    zoomImage(delta);
}

// é‡ç½®ç¼©æ”¾
function resetZoom() {
    if (!currentImageData) return;
    
    zoomLevel = 1;
    redrawCanvas();
    updateZoomDisplay();
    resetSelection();
}

// é€‚åº”çª—å£
function fitToWindow() {
    if (!currentImageData) return;
    
    const containerRect = elements.imageContainer.getBoundingClientRect();
    const maxWidth = containerRect.width - 40;
    const maxHeight = containerRect.height - 40;
    
    const newScale = Math.min(
        maxWidth / currentImageData.width,
        maxHeight / currentImageData.height,
        1
    );
    
    scale = newScale;
    zoomLevel = 1;
    redrawCanvas();
    updateZoomDisplay();
    resetSelection();
}

// æ›´æ–°ç¼©æ”¾æ˜¾ç¤º
function updateZoomDisplay() {
    const percentage = Math.round(scale * zoomLevel * 100);
    elements.zoomLevel.textContent = `${percentage}%`;
}

// å®¹å™¨é¼ æ ‡æŒ‰ä¸‹ï¼ˆæ‹–åŠ¨ï¼‰
function onContainerMouseDown(e) {
    if (!currentImageData) return;
    
    // åªæœ‰å³é”®æ‰å¼€å§‹æ‹–åŠ¨
    if (e.button !== 2) return;
    
    isDragging = true;
    dragStart.x = e.clientX;
    dragStart.y = e.clientY;
    scrollStart.x = elements.imageContainer.scrollLeft;
    scrollStart.y = elements.imageContainer.scrollTop;
    elements.imageContainer.classList.add('dragging');
    
    e.preventDefault();
}

// å®¹å™¨é¼ æ ‡ç§»åŠ¨ï¼ˆæ‹–åŠ¨ï¼‰
function onContainerMouseMove(e) {
    if (!isDragging) return;
    
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;
    
    // è®¡ç®—æ–°çš„æ»šåŠ¨ä½ç½®
    let newScrollLeft = scrollStart.x - dx;
    let newScrollTop = scrollStart.y - dy;
    
    // é™åˆ¶æ»šåŠ¨èŒƒå›´ï¼Œç¡®ä¿å›¾ç‰‡è‡³å°‘æœ‰ä¸€éƒ¨åˆ†å¯è§
    const container = elements.imageContainer;
    const maxScrollLeft = container.scrollWidth - container.clientWidth;
    const maxScrollTop = container.scrollHeight - container.clientHeight;
    
    // è¾¹ç•Œé™åˆ¶
    newScrollLeft = Math.max(0, Math.min(newScrollLeft, maxScrollLeft));
    newScrollTop = Math.max(0, Math.min(newScrollTop, maxScrollTop));
    
    elements.imageContainer.scrollLeft = newScrollLeft;
    elements.imageContainer.scrollTop = newScrollTop;
}

// å®¹å™¨é¼ æ ‡æŠ¬èµ·ï¼ˆæ‹–åŠ¨ï¼‰
function onContainerMouseUp(e) {
    isDragging = false;
    elements.imageContainer.classList.remove('dragging');
}

// ========== å·¥å…·å‡½æ•° ==========

// ç”ŸæˆéšæœºID
function generateRandomId(length) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
}

// æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
function showStatus(message, type = 'info') {
    elements.statusMessage.textContent = message;
    elements.statusMessage.className = `status-message ${type}`;
    
    // è‡ªåŠ¨éšè—æˆåŠŸæ¶ˆæ¯
    if (type === 'success') {
        setTimeout(() => {
            elements.statusMessage.className = 'status-message';
        }, 5000);
    }
}

// ========== æ ‡ç­¾é¡µåˆ‡æ¢ ==========

// åˆ‡æ¢æ ‡ç­¾é¡µ
function switchTab(tabName) {
    if (tabName === 'crop') {
        elements.cropTabBtn.classList.add('active');
        elements.nodesTabBtn.classList.remove('active');
        elements.cropPanel.classList.add('active');
        elements.nodesPanel.classList.remove('active');
    } else if (tabName === 'nodes') {
        elements.cropTabBtn.classList.remove('active');
        elements.nodesTabBtn.classList.add('active');
        elements.cropPanel.classList.remove('active');
        elements.nodesPanel.classList.add('active');
    }
}

// ========== èŠ‚ç‚¹æŠ“å–åŠŸèƒ½ ==========

// æŠ“å–UIå±‚çº§ç»“æ„
async function dumpUIHierarchy() {
    if (!selectedDevice) {
        showStatus('è¯·å…ˆé€‰æ‹©è®¾å¤‡', 'warning');
        return;
    }
    
    showStatus('æ­£åœ¨æŠ“å–UIå±‚çº§ä¿¡æ¯å’Œæˆªå›¾...', 'info');
    elements.dumpUIBtn.disabled = true;
    
    try {
        const result = await window.electronAPI.dumpUIHierarchy(selectedDevice);
        
        if (result.success) {
            // ä¿å­˜å½“å‰æˆªå›¾è·¯å¾„
            currentImagePath = result.screenshotPath;
            
            // åŠ è½½å¹¶æ˜¾ç¤ºæˆªå›¾
            await loadAndDisplayImage(currentImagePath);
            
            // è§£æXMLæ•°æ®
            uiHierarchyData = parseUIXML(result.xmlContent);
            
            // æ¸²æŸ“èŠ‚ç‚¹æ ‘
            renderNodesTree(uiHierarchyData);
            
            // æ·»åŠ åˆ°å†å²è®°å½•ï¼ˆåŒ…å«èŠ‚ç‚¹æ•°æ®ï¼‰
            addToHistory(result.screenshotPath, result.screenshotFileName, result.timestamp, result.xmlPath, result.xmlFileName);
            
            // åˆ‡æ¢åˆ°èŠ‚ç‚¹ä¿¡æ¯æ ‡ç­¾é¡µ
            switchTab('nodes');
            
            // å¯ç”¨ä¿å­˜åŸå›¾æŒ‰é’®
            elements.saveOriginalBtn.disabled = false;
            
            showStatus('UIå±‚çº§ä¿¡æ¯å’Œæˆªå›¾æŠ“å–æˆåŠŸï¼ç‚¹å‡»èŠ‚ç‚¹å¯åœ¨å›¾ç‰‡ä¸ŠæŸ¥çœ‹ä½ç½®', 'success');
        } else {
            showStatus(`æŠ“å–å¤±è´¥: ${result.error}`, 'error');
        }
    } catch (error) {
        showStatus(`æŠ“å–å¤±è´¥: ${error.message}`, 'error');
    } finally {
        elements.dumpUIBtn.disabled = false;
    }
}

// è§£æUIå±‚çº§XML
function parseUIXML(xmlString) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
    
    // æ£€æŸ¥è§£æé”™è¯¯
    const parserError = xmlDoc.querySelector('parsererror');
    if (parserError) {
        throw new Error('XMLè§£æå¤±è´¥');
    }
    
    // é€’å½’è§£æèŠ‚ç‚¹
    function parseNode(xmlNode, depth = 0) {
        const nodeData = {
            tag: xmlNode.tagName,
            attributes: {},
            children: [],
            depth: depth,
            id: generateRandomId(8)
        };
        
        // æå–æ‰€æœ‰å±æ€§
        for (let i = 0; i < xmlNode.attributes.length; i++) {
            const attr = xmlNode.attributes[i];
            nodeData.attributes[attr.name] = attr.value;
        }
        
        // è§£æå­èŠ‚ç‚¹
        for (let i = 0; i < xmlNode.children.length; i++) {
            const childNode = parseNode(xmlNode.children[i], depth + 1);
            nodeData.children.push(childNode);
        }
        
        return nodeData;
    }
    
    // ä»æ ¹èŠ‚ç‚¹å¼€å§‹è§£æ
    const rootNode = xmlDoc.documentElement;
    return parseNode(rootNode);
}

// æ¸²æŸ“èŠ‚ç‚¹æ ‘
function renderNodesTree(nodeData) {
    elements.nodesTree.innerHTML = '';
    
    if (!nodeData) {
        elements.nodesTree.innerHTML = '<p class="empty-state">æ— èŠ‚ç‚¹æ•°æ®</p>';
        return;
    }
    
    const treeContainer = document.createElement('div');
    treeContainer.className = 'tree-root';
    
    // é€’å½’æ¸²æŸ“èŠ‚ç‚¹
    function renderNode(node, parentElement) {
        const nodeItem = document.createElement('div');
        nodeItem.className = 'tree-node';
        nodeItem.dataset.nodeId = node.id;
        nodeItem.dataset.depth = node.depth;
        // ä¿å­˜åŸå§‹èŠ‚ç‚¹æ•°æ®ä¾›æœç´¢ä½¿ç”¨
        nodeItem._nodeData = node;
        
        // åˆ›å»ºèŠ‚ç‚¹å†…å®¹å®¹å™¨
        const nodeContent = document.createElement('div');
        nodeContent.className = 'tree-node-content';
        
        // ç¼©è¿›
        const indent = document.createElement('span');
        indent.className = 'tree-indent';
        indent.style.width = (node.depth * 20) + 'px';
        
        // å±•å¼€/æŠ˜å æŒ‰é’®
        const toggle = document.createElement('span');
        toggle.className = 'tree-toggle';
        if (node.children.length > 0) {
            toggle.textContent = 'â–¶';
            toggle.classList.add('has-children');
        } else {
            toggle.textContent = 'â€¢';
        }
        
        // èŠ‚ç‚¹æ ‡ç­¾
        const label = document.createElement('span');
        label.className = 'tree-label';
        
        // æ„å»ºèŠ‚ç‚¹æ˜¾ç¤ºæ–‡æœ¬
        let displayText = node.tag;
        const resId = node.attributes['resource-id'] || '';
        const text = node.attributes['text'] || '';
        const className = node.attributes['class'] || '';
        
        if (resId) {
            displayText += ` [${resId.split('/').pop()}]`;
        }
        if (text && text.length < 20) {
            displayText += ` "${text}"`;
        }
        if (!resId && className) {
            displayText += ` (${className.split('.').pop()})`;
        }
        
        label.textContent = displayText;
        
        // ç»„è£…èŠ‚ç‚¹å†…å®¹
        nodeContent.appendChild(indent);
        nodeContent.appendChild(toggle);
        nodeContent.appendChild(label);
        nodeItem.appendChild(nodeContent);
        
        // ç‚¹å‡»å±•å¼€/æŠ˜å 
        toggle.addEventListener('click', (e) => {
            e.stopPropagation();
            if (node.children.length > 0) {
                nodeItem.classList.toggle('expanded');
                toggle.textContent = nodeItem.classList.contains('expanded') ? 'â–¼' : 'â–¶';
            }
        });
        
        // ç‚¹å‡»é€‰ä¸­èŠ‚ç‚¹
        nodeContent.addEventListener('click', (e) => {
            e.stopPropagation();
            selectNode(node, nodeItem);
        });
        
        parentElement.appendChild(nodeItem);
        
        // æ¸²æŸ“å­èŠ‚ç‚¹å®¹å™¨
        if (node.children.length > 0) {
            const childrenContainer = document.createElement('div');
            childrenContainer.className = 'tree-children';
            nodeItem.appendChild(childrenContainer);
            
            // é€’å½’æ¸²æŸ“å­èŠ‚ç‚¹
            node.children.forEach(child => {
                renderNode(child, childrenContainer);
            });
        }
    }
    
    renderNode(nodeData, treeContainer);
    elements.nodesTree.appendChild(treeContainer);
}

// é€‰ä¸­èŠ‚ç‚¹
function selectNode(node, nodeElement) {
    selectedNode = node;
    
    // æ›´æ–°é€‰ä¸­çŠ¶æ€
    elements.nodesTree.querySelectorAll('.tree-node').forEach(el => {
        el.classList.remove('selected');
    });
    nodeElement.classList.add('selected');
    
    // æ˜¾ç¤ºèŠ‚ç‚¹è¯¦æƒ…
    displayNodeDetails(node);
    
    // åœ¨å›¾ç‰‡ä¸Šé«˜äº®æ˜¾ç¤ºèŠ‚ç‚¹ä½ç½®
    highlightNodeOnImage(node);
}

// æ˜¾ç¤ºèŠ‚ç‚¹è¯¦æƒ…
function displayNodeDetails(node) {
    if (!node) {
        elements.nodeDetails.innerHTML = '<p class="empty-state">è¯·åœ¨å·¦ä¾§æ ‘ä¸­é€‰æ‹©èŠ‚ç‚¹</p>';
        return;
    }
    
    let html = '<div class="node-details-content">';
    
    // æ˜¾ç¤ºæ ‡ç­¾
    html += `<div class="detail-item"><strong>æ ‡ç­¾:</strong> <span>${node.tag}</span></div>`;
    
    // æ˜¾ç¤ºæ‰€æœ‰å±æ€§
    const importantAttrs = ['resource-id', 'class', 'package', 'text', 'content-desc', 'checkable', 'checked', 'clickable', 'enabled', 'focusable', 'focused', 'scrollable', 'long-clickable', 'password', 'selected', 'bounds'];
    
    for (const attr of importantAttrs) {
        if (node.attributes[attr] !== undefined) {
            let value = node.attributes[attr];
            // é«˜äº®æ˜¾ç¤ºboundsåæ ‡
            if (attr === 'bounds') {
                value = `<code>${value}</code>`;
            }
            html += `<div class="detail-item"><strong>${attr}:</strong> <span>${value}</span></div>`;
        }
    }
    
    // æ˜¾ç¤ºå…¶ä»–å±æ€§
    for (const attr in node.attributes) {
        if (!importantAttrs.includes(attr)) {
            html += `<div class="detail-item"><strong>${attr}:</strong> <span>${node.attributes[attr]}</span></div>`;
        }
    }
    
    // æ˜¾ç¤ºå­èŠ‚ç‚¹æ•°é‡
    html += `<div class="detail-item"><strong>å­èŠ‚ç‚¹æ•°:</strong> <span>${node.children.length}</span></div>`;
    
    html += '</div>';
    
    elements.nodeDetails.innerHTML = html;
}

// èŠ‚ç‚¹æœç´¢
function onNodeSearch(e) {
    const searchText = e.target.value.toLowerCase().trim();
    
    // æ¸…é™¤ä¹‹å‰é€‰ä¸­çš„èŠ‚ç‚¹
    selectedNode = null;
    elements.nodesTree.querySelectorAll('.tree-node').forEach(node => {
        node.classList.remove('selected');
    });
    elements.nodeDetails.innerHTML = '<p class="empty-state">è¯·åœ¨å·¦ä¾§æ ‘ä¸­é€‰æ‹©èŠ‚ç‚¹</p>';
    // éšè—èŠ‚ç‚¹é«˜äº®æ¡†
    elements.nodeHighlightOverlay.style.display = 'none';
    
    if (!searchText) {
        // æ¸…ç©ºæœç´¢ï¼Œæ˜¾ç¤ºæ‰€æœ‰èŠ‚ç‚¹
        elements.nodesTree.querySelectorAll('.tree-node').forEach(node => {
            node.style.display = '';
            node.classList.remove('search-match');
        });
        return;
    }
    
    // console.log('ğŸ” å¼€å§‹æœç´¢:', searchText);
    let matchCount = 0;
    
    // æœç´¢å¹¶é«˜äº®åŒ¹é…çš„èŠ‚ç‚¹
    elements.nodesTree.querySelectorAll('.tree-node').forEach(nodeElement => {
        // è·å–èŠ‚ç‚¹çš„åŸå§‹æ•°æ®
        const nodeData = nodeElement._nodeData;
        if (!nodeData) {
            console.warn('âš ï¸ èŠ‚ç‚¹ç¼ºå°‘ _nodeData:', nodeElement);
            return;
        }
        
        // æœç´¢æ‰€æœ‰ç›¸å…³å±æ€§ï¼ˆåŒ…å«åŒ¹é…ï¼‰
        const matches = 
            nodeData.tag.toLowerCase().includes(searchText) ||
            (nodeData.attributes['resource-id'] || '').toLowerCase().includes(searchText) ||
            (nodeData.attributes['text'] || '').toLowerCase().includes(searchText) ||
            (nodeData.attributes['content-desc'] || '').toLowerCase().includes(searchText) ||
            (nodeData.attributes['class'] || '').toLowerCase().includes(searchText) ||
            (nodeData.attributes['package'] || '').toLowerCase().includes(searchText);
        
        if (matches) {
            matchCount++;
            nodeElement.style.display = '';
            nodeElement.classList.add('search-match');
            
            // è¾“å‡ºåŒ¹é…çš„èŠ‚ç‚¹ä¿¡æ¯
            // console.log('âœ… åŒ¹é…èŠ‚ç‚¹:', {
            //     tag: nodeData.tag,
            //     'resource-id': nodeData.attributes['resource-id'],
            //     text: nodeData.attributes['text'],
            //     'content-desc': nodeData.attributes['content-desc'],
            //     class: nodeData.attributes['class']
            // });
            
            // å±•å¼€çˆ¶èŠ‚ç‚¹ä»¥æ˜¾ç¤ºåŒ¹é…é¡¹
            let parent = nodeElement.parentElement;
            while (parent && parent.classList.contains('tree-children')) {
                const parentNode = parent.parentElement;
                if (parentNode && parentNode.classList.contains('tree-node')) {
                    parentNode.classList.add('expanded');
                    parentNode.style.display = ''; // ç¡®ä¿çˆ¶èŠ‚ç‚¹ä¹Ÿæ˜¾ç¤º
                    const toggle = parentNode.querySelector('.tree-toggle');
                    if (toggle) {
                        toggle.textContent = 'â–¼';
                    }
                }
                parent = parentNode ? parentNode.parentElement : null;
            }
        } else {
            nodeElement.style.display = 'none';
            nodeElement.classList.remove('search-match');
        }
    });
    
    // console.log(`ğŸ“Š æœç´¢å®Œæˆï¼Œæ‰¾åˆ° ${matchCount} ä¸ªåŒ¹é…èŠ‚ç‚¹`);
}

// å±•å¼€æ‰€æœ‰èŠ‚ç‚¹
function expandAllNodes() {
    elements.nodesTree.querySelectorAll('.tree-node').forEach(node => {
        if (node.querySelector('.tree-toggle.has-children')) {
            node.classList.add('expanded');
            const toggle = node.querySelector('.tree-toggle');
            if (toggle) {
                toggle.textContent = 'â–¼';
            }
        }
    });
}

// æŠ˜å æ‰€æœ‰èŠ‚ç‚¹
function collapseAllNodes() {
    elements.nodesTree.querySelectorAll('.tree-node').forEach(node => {
        node.classList.remove('expanded');
        const toggle = node.querySelector('.tree-toggle');
        if (toggle && toggle.classList.contains('has-children')) {
            toggle.textContent = 'â–¶';
        }
    });
}

// åœ¨å›¾ç‰‡ä¸Šé«˜äº®æ˜¾ç¤ºèŠ‚ç‚¹ä½ç½®
function highlightNodeOnImage(node) {
    // å¦‚æœæ²¡æœ‰å›¾ç‰‡ï¼Œä¸æ˜¾ç¤ºé«˜äº®
    if (!currentImageData) {
        hideNodeHighlight();
        return;
    }
    
    // è·å–èŠ‚ç‚¹çš„ bounds å±æ€§
    const bounds = node.attributes['bounds'];
    if (!bounds) {
        hideNodeHighlight();
        return;
    }
    
    // è§£æ bounds: [x1,y1][x2,y2]
    const boundsRect = parseBounds(bounds);
    if (!boundsRect) {
        hideNodeHighlight();
        return;
    }
    
    // è®¡ç®—åœ¨å½“å‰ç¼©æ”¾ä¸‹çš„æ˜¾ç¤ºåæ ‡
    const displayRect = {
        x: boundsRect.x * scale * zoomLevel,
        y: boundsRect.y * scale * zoomLevel,
        width: boundsRect.width * scale * zoomLevel,
        height: boundsRect.height * scale * zoomLevel
    };
    
    // æ˜¾ç¤ºé«˜äº®æ¡†
    elements.nodeHighlightBox.style.left = displayRect.x + 'px';
    elements.nodeHighlightBox.style.top = displayRect.y + 'px';
    elements.nodeHighlightBox.style.width = displayRect.width + 'px';
    elements.nodeHighlightBox.style.height = displayRect.height + 'px';
    elements.nodeHighlightOverlay.style.display = 'block';
}

// éšè—èŠ‚ç‚¹é«˜äº®
function hideNodeHighlight() {
    if (elements.nodeHighlightOverlay) {
        elements.nodeHighlightOverlay.style.display = 'none';
    }
}

// è§£æ bounds å­—ç¬¦ä¸²: [x1,y1][x2,y2]
function parseBounds(boundsStr) {
    try {
        // åŒ¹é…æ ¼å¼ [x1,y1][x2,y2]
        const match = boundsStr.match(/\[(\d+),(\d+)\]\[(\d+),(\d+)\]/);
        if (!match) {
            return null;
        }
        
        const x1 = parseInt(match[1]);
        const y1 = parseInt(match[2]);
        const x2 = parseInt(match[3]);
        const y2 = parseInt(match[4]);
        
        return {
            x: x1,
            y: y1,
            width: x2 - x1,
            height: y2 - y1
        };
    } catch (error) {
        console.error('è§£æ bounds å¤±è´¥:', error);
        return null;
    }
}

// æŸ¥æ‰¾åŒ…å«æŒ‡å®šåæ ‡çš„èŠ‚ç‚¹ï¼ˆé€’å½’æŸ¥æ‰¾æœ€å°çš„åŒ¹é…èŠ‚ç‚¹ï¼‰
function findNodeByCoordinates(x, y, node = uiHierarchyData, depth = 0) {
    if (!node) {
        if (depth === 0) console.log('èŠ‚ç‚¹æ•°æ®ä¸ºç©º');
        return null;
    }
    
    // è·å–èŠ‚ç‚¹çš„ bounds
    const bounds = node.attributes['bounds'];
    
    // å¦‚æœå½“å‰èŠ‚ç‚¹æ²¡æœ‰ boundsï¼ˆå¦‚æ ¹èŠ‚ç‚¹ hierarchyï¼‰ï¼Œåˆ™åœ¨å­èŠ‚ç‚¹ä¸­æŸ¥æ‰¾
    if (!bounds) {
        if (depth === 0) console.log('æ ¹èŠ‚ç‚¹æ²¡æœ‰ boundsï¼Œä»å­èŠ‚ç‚¹å¼€å§‹æŸ¥æ‰¾');
        
        if (node.children && node.children.length > 0) {
            // æ”¶é›†æ‰€æœ‰åŒ¹é…çš„å­èŠ‚ç‚¹
            let bestMatch = null;
            let minArea = Infinity;
            
            for (let child of node.children) {
                const foundChild = findNodeByCoordinates(x, y, child, depth + 1);
                if (foundChild) {
                    const childBounds = foundChild.attributes['bounds'];
                    if (childBounds) {
                        const childRect = parseBounds(childBounds);
                        if (childRect) {
                            const area = childRect.width * childRect.height;
                            if (area < minArea) {
                                minArea = area;
                                bestMatch = foundChild;
                            }
                        }
                    }
                }
            }
            
            if (depth === 0 && !bestMatch) {
                console.log('åœ¨æ‰€æœ‰å­èŠ‚ç‚¹ä¸­æœªæ‰¾åˆ°åŒ¹é…');
            }
            return bestMatch;
        }
        
        return null;
    }
    
    const rect = parseBounds(bounds);
    if (!rect) {
        console.log('bounds è§£æå¤±è´¥:', bounds);
        return null;
    }
    
    if (depth === 0) {
        console.log('å¼€å§‹æŸ¥æ‰¾ï¼Œåæ ‡:', x, y);
    }
    
    // æ£€æŸ¥åæ ‡æ˜¯å¦åœ¨å½“å‰èŠ‚ç‚¹èŒƒå›´å†…
    if (x >= rect.x && x <= rect.x + rect.width &&
        y >= rect.y && y <= rect.y + rect.height) {
        
        // æ”¶é›†æ‰€æœ‰åŒ¹é…çš„å­èŠ‚ç‚¹ï¼Œæ‰¾åˆ°é¢ç§¯æœ€å°çš„
        let bestMatch = node; // é»˜è®¤ä¸ºå½“å‰èŠ‚ç‚¹
        let minArea = rect.width * rect.height;
        
        if (node.children && node.children.length > 0) {
            for (let child of node.children) {
                const foundChild = findNodeByCoordinates(x, y, child, depth + 1);
                if (foundChild) {
                    const childBounds = foundChild.attributes['bounds'];
                    if (childBounds) {
                        const childRect = parseBounds(childBounds);
                        if (childRect) {
                            const area = childRect.width * childRect.height;
                            if (area < minArea) {
                                minArea = area;
                                bestMatch = foundChild;
                            }
                        }
                    }
                }
            }
        }
        
        // è¿”å›é¢ç§¯æœ€å°çš„åŒ¹é…èŠ‚ç‚¹
        if (bestMatch === node) {
            console.log('æ‰¾åˆ°èŠ‚ç‚¹ï¼ˆå½“å‰å±‚çº§ï¼‰:', node.tag, rect, 'é¢ç§¯:', minArea);
        }
        return bestMatch;
    }
    
    return null;
}

// ========== æ‹–åŠ¨è°ƒæ•´å¤§å° ==========

let isResizing = false;

// å¼€å§‹æ‹–åŠ¨è°ƒæ•´å¤§å°
function startResize(e) {
    isResizing = true;
    document.body.style.cursor = 'col-resize';
    document.body.style.userSelect = 'none';
    
    // æ·»åŠ å…¨å±€ç›‘å¬å™¨
    document.addEventListener('mousemove', doResize);
    document.addEventListener('mouseup', stopResize);
    
    e.preventDefault();
}

// æ‰§è¡Œè°ƒæ•´å¤§å°
function doResize(e) {
    if (!isResizing) return;
    
    // è·å–çª—å£å®½åº¦å’Œé¼ æ ‡ä½ç½®
    const windowWidth = window.innerWidth;
    const mouseX = e.clientX;
    
    // è®¡ç®—æ–°çš„å³ä¾§è¾¹æ å®½åº¦ï¼ˆä»å³è¾¹ç•Œåˆ°é¼ æ ‡ä½ç½®ï¼‰
    const newWidth = windowWidth - mouseX - 5; // å‡å»åˆ†éš”æ¡å®½åº¦
    
    // é™åˆ¶åœ¨æœ€å°å’Œæœ€å¤§å®½åº¦ä¹‹é—´
    const minWidth = 250;
    const maxWidth = 600;
    const finalWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
    
    // åº”ç”¨æ–°å®½åº¦
    elements.sidebarRight.style.width = finalWidth + 'px';
}

// åœæ­¢æ‹–åŠ¨è°ƒæ•´å¤§å°
function stopResize() {
    isResizing = false;
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
    
    // ç§»é™¤å…¨å±€ç›‘å¬å™¨
    document.removeEventListener('mousemove', doResize);
    document.removeEventListener('mouseup', stopResize);
}

// åœ¨èŠ‚ç‚¹æ ‘ä¸­å±•å¼€å¹¶é€‰ä¸­èŠ‚ç‚¹
function expandAndSelectNodeInTree(targetNode) {
    if (!targetNode) return;
    
    // æ‰¾åˆ°æ‰€æœ‰éœ€è¦å±•å¼€çš„çˆ¶èŠ‚ç‚¹è·¯å¾„
    const pathToNode = [];
    
    function findPath(node, path = []) {
        if (node.id === targetNode.id) {
            pathToNode.push(...path);
            return true;
        }
        
        if (node.children && node.children.length > 0) {
            for (let child of node.children) {
                if (findPath(child, [...path, node])) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    if (uiHierarchyData) {
        findPath(uiHierarchyData);
    }
    
    // å±•å¼€æ‰€æœ‰çˆ¶èŠ‚ç‚¹
    pathToNode.forEach(parentNode => {
        const nodeElement = elements.nodesTree.querySelector(`[data-node-id="${parentNode.id}"]`);
        if (nodeElement) {
            nodeElement.classList.add('expanded');
            const toggle = nodeElement.querySelector('.tree-toggle');
            if (toggle && toggle.classList.contains('has-children')) {
                toggle.textContent = 'â–¼';
            }
        }
    });
    
    // é€‰ä¸­ç›®æ ‡èŠ‚ç‚¹
    const targetElement = elements.nodesTree.querySelector(`[data-node-id="${targetNode.id}"]`);
    if (targetElement) {
        selectNode(targetNode, targetElement);
        
        // æ»šåŠ¨åˆ°å¯è§åŒºåŸŸ
        targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // åˆ‡æ¢åˆ°èŠ‚ç‚¹ä¿¡æ¯æ ‡ç­¾é¡µ
        switchTab('nodes');
    }
}
